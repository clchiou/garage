#!/usr/bin/env python3
"""Run a pod for exploration."""

import json
import logging
import shutil
import tempfile

from startup import startup

import g1.scripts.parts
from g1 import scripts
from g1.apps import bases
from g1.bases import argparses
from g1.bases.assertions import ASSERT

LOG = logging.getLogger()  # Use the root logger.

CTR = None  # Resolve it in main.


@startup
def add_arguments(parser: bases.LABELS.parser) -> bases.LABELS.parse:
    parser.add_argument(
        '--pod-id',
        help='provide pod id',
    )
    parser.add_argument(
        '--keep',
        action=argparses.StoreBoolAction,
        default=False,
        help='keep pod after exit (default: %(default_string)s)',
    )
    parser.add_argument(
        '--image-id',
        action=argparses.AppendConstAndValueAction,
        dest='image',
        const='id',
        help='add image by id',
    )
    parser.add_argument(
        '--image-nv',
        action=argparses.AppendConstAndValueAction,
        dest='image',
        const='nv',
        metavar=('NAME', 'VERSION'),
        nargs=2,
        help='add image by name and version',
    )
    parser.add_argument(
        '--image-tag',
        action=argparses.AppendConstAndValueAction,
        dest='image',
        const='tag',
        help='add image by tag',
    )
    parser.add_argument(
        '--mount',
        action='append',
        help='add mount of the form "source:target[:ro]"',
    )


def main(
    args: bases.LABELS.args,
    _: g1.scripts.parts.LABELS.setup,
):
    # Resolve ctr location because sudo does not look up custom paths.
    global CTR
    CTR = ASSERT.not_none(shutil.which('ctr'))
    LOG.info('use ctr: %s', CTR)

    pod_id = init(args)
    run_pod(pod_id)
    # Only remove on normal exit; on error, keep pod for diagnosis.
    if not args.keep:
        remove_pod(pod_id)
    return 0


def init(args):
    pod_id = args.pod_id or generate_pod_id()
    LOG.info('use pod id: %s', pod_id)
    images = parse_image_args(ASSERT.not_empty(args.image or ()))
    mounts = parse_mount_args(args.mount or ())
    with tempfile.NamedTemporaryFile(suffix='.json') as config_tempfile:
        config_path = config_tempfile.name
        write_config(images, mounts, config_path)
        prepare_pod(pod_id, config_path)
    return pod_id


def generate_pod_id():
    with scripts.doing_capture_output():
        proc = scripts.run([CTR, 'pods', 'generate-id'])
        return proc.stdout.decode('utf-8').strip()


def parse_image_args(image_args):
    images = []
    for arg in image_args:
        if arg[0] == 'id':
            images.append({'id': arg[1]})
        elif arg[0] == 'nv':
            images.append({'name': arg[1][0], 'version': arg[1][1]})
        elif arg[0] == 'tag':
            images.append({'tag': arg[1]})
        else:
            ASSERT.unreachable('unknown image arg: {}', arg)
    return images


def parse_mount_args(mount_args):
    mounts = []
    for arg in mount_args:
        parts = arg.split(':')
        if ASSERT.in_(len(parts), (2, 3)) == 3:
            source, target, read_only = parts
            read_only = read_only == 'ro'
        else:
            source, target = parts
            read_only = False
        mounts.append({
            'source': source,
            'target': target,
            'read_only': read_only,
        })
    return mounts


def write_config(images, mounts, config_path):
    LOG.info('write config to: %s', config_path)
    config = {
        'name': 'explorer',
        'version': '0.0.1',
        'apps': [],
        'images': images,
        'mounts': mounts,
    }
    with open(config_path, 'w') as config_file:
        json.dump(config, config_file)


def prepare_pod(pod_id, config_path):
    with scripts.using_sudo():
        scripts.run([CTR, 'pods', 'prepare', '--id', pod_id, config_path])


def run_pod(pod_id):
    with scripts.using_sudo():
        scripts.run([CTR, 'pods', 'run-prepared', pod_id])


def remove_pod(pod_id):
    with scripts.using_sudo():
        scripts.run([CTR, 'pods', 'remove', pod_id])


if __name__ == '__main__':
    bases.run(main)
