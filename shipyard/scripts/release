#!/usr/bin/env python3

from collections import OrderedDict
from pathlib import Path
import logging
import os
import sys

import yaml

ROOT = Path(__file__).absolute().parent.parent.parent
sys.path.append(str(ROOT / 'py' / 'foreman'))
sys.path.append(str(ROOT / 'py' / 'garage'))
sys.path.append(str(ROOT / 'py' / 'startup'))
sys.path.append(str(ROOT / 'shipyard'))

from foreman import Label

from garage import apps
from garage import scripts
from garage.formatters.yaml import represent_mapping

import shipyard
import shipyard.release


LOG = logging.getLogger(__name__)


# We search ${OPS_ROOT}/releases for releases by default
OPS_ROOT = scripts.ensure_path(os.environ.get('OPS_ROOT'))


with_argument_podv_list = apps.with_argument(
    'podv', nargs='+',
    help='add versioned pod label (format: "//label@version")',
)


with_argument_podv = apps.with_argument(
    'podv',
    help='set versioned pod label (format: "//label@version")',
)


def parse_podv_list(podv_list):
    labels_versions = OrderedDict()  # As ordered set
    for label_version in podv_list:
        labels_versions[parse_podv(label_version)] = None
    return list(labels_versions)


def parse_podv(podv):
    label, version = podv.rsplit('@', maxsplit=1)
    label = Label.parse(label)
    return label, version


@apps.with_prog('read-prop')
@apps.with_help('read build rule property')
@shipyard.with_foreman_argument
@apps.with_argument(
    'property', choices=('rule-type', 'label'),
    help='choose property',
)
@apps.with_argument(
    'rule', help='set pod build rule',
)
def read_property(args):
    """Read build rule property."""
    rules = shipyard.RuleIndex(args)
    rules.load_from_labels([args.rule])
    rule_obj = rules.get_rule(args.rule)
    rule_type = rule_obj.annotations.get('rule-type')
    if args.property == 'rule-type':
        if rule_type is not None:
            print(rule_type)
        else:
            LOG.warning('rule %s has no rule-type annotation', args.rule)
    elif args.property == 'label':
        # FIXME: This is probably confusing: For build rules that are
        # not annotated with rule-type, we treat it as a build_pod rule
        # for convenience.
        if rule_type == 'build_pod' or rule_type is None:
            print(rules.get_pod_name(rule_obj))
        elif rule_type == 'build_volume':
            print(rules.get_volume_name(rule_obj))
        else:
            LOG.warning('label is undefined for rule %s', args.rule)
    else:
        raise AssertionError
    return 0


@apps.with_prog('gen-inst')
@apps.with_help('generate instruction file')
@shipyard.with_foreman_argument
@apps.with_argument(
    '--repo', metavar=('SCM', 'PATH'), nargs=2, action='append',
    help='add source repo to revision stamp (SCM: git, hg)',
)
@shipyard.with_argument_input
@apps.with_argument(
    '--default', metavar='PATH',
    help='provide default values to the instruction',
)
@apps.with_argument(
    'rule', help='set pod build rule',
)
@apps.with_argument(
    'version', help='set pod version',
)
def generate_instruction(args):
    """Generate instruction file."""

    # Preserve order for readability (PyYAML sucks in this regard).
    yaml.SafeDumper.add_representer(OrderedDict, represent_mapping)

    instruction_data = OrderedDict([
        ('rule', args.rule),
        ('revisions', []),
    ])

    rules = shipyard.RuleIndex(args)
    rules.load_from_labels([args.rule])
    rule_obj = rules.get_rule(args.rule)
    # FIXME: This is probably confusing: For build rules that are not
    # annotated with rule-type, we treat it as a build_pod rule for
    # convenience.
    rule_type = rule_obj.annotations.get('rule-type', 'build_pod')
    if rule_type == 'build_pod':
        label = rules.get_pod_name(rule_obj)
        kind = 'pods'
    elif rule_type == 'build_volume':
        label = rules.get_volume_name(rule_obj)
        kind = 'volumes'
    else:
        raise ValueError(
            'expect build_pod or build_volume type of rule: %s' % args.rule)

    default_path = None
    if args.default:
        default_path = Path(args.default)
    elif args.input_root:
        # If no default from command-line, look up one from input.
        default_path = shipyard.find_default_path(args.input_root, kind, label)
        if default_path is not None:
            LOG.info('use default: %s', default_path)
    if default_path is not None:
        default = yaml.load(default_path.read_text())
        # Restrict default to these fields.
        for block_name in ('images', 'volumes', 'parameters'):
            block = default.get(block_name)
            if block:
                instruction_data[block_name] = OrderedDict(
                    (name, block[name])
                    for name in sorted(block)
                )

    revisions = instruction_data['revisions']
    source_repos = [('git', ROOT)]
    source_repos.extend(args.repo or ())
    for scm, repo_path in source_repos:
        repo_path = scripts.ensure_directory(repo_path)
        if scm == 'git':
            url, revision, dirty = shipyard.release.get_git_stamp(repo_path)
        elif scm == 'hg':
            url, revision, dirty = shipyard.release.get_hg_stamp(repo_path)
        else:
            raise RuntimeError('unsupported scm: %s' % scm)
        LOG.info('stamp: %s %s %s%s', scm, url, '*' if dirty else '', revision)
        revisions.append(OrderedDict([
            ('scm', scm),
            ('url', url),
            ('revision', revision),
            ('dirty', dirty),
        ]))

    instruction_data = yaml.safe_dump(
        instruction_data,
        default_flow_style=False,
        explicit_start=True,
        indent=2,
    )

    path = shipyard.release.ReleaseRepo.get_instruction_path(
        args.release_root, kind, label, args.version)
    if path.exists():
        LOG.warning('overwrite %s', path)
    with scripts.dry_run(args.dry_run):
        scripts.mkdir(path.parent)
        scripts.ensure_contents(path, instruction_data)

    return 0


@apps.with_prog('cat-inst')
@apps.with_help('print out instruction file')
@with_argument_podv
def cat_instruction(args):
    """Print out instruction file."""
    label, version = parse_podv(args.podv)
    _, path = shipyard.release.ReleaseRepo.detect_instruction_path(
        args.release_root, label, version)
    print(path.read_text(), end='')
    return 0


@apps.with_help('build pods')
@shipyard.with_foreman_argument
@shipyard.with_builder_argument
@shipyard.with_argument_input
@with_argument_podv_list
def build(args):
    """Build pods from versioned labels."""

    rules = shipyard.RuleIndex(args)
    builder = shipyard.Builder(args)
    repo = shipyard.release.ReleaseRepo(args.release_root, rules)

    labels_versions = parse_podv_list(args.podv)
    instructions = repo.load_instructions(labels_versions)

    with scripts.dry_run(args.dry_run):
        okay = shipyard.release.execute_instructions(
            instructions, repo, builder, args.input_root or ())
    return 0 if okay else 1


@apps.with_prog('build-inst')
@apps.with_help('build pods from instruction files')
@shipyard.with_foreman_argument
@shipyard.with_builder_argument
@shipyard.with_argument_input
@apps.with_argument(
    'instruction', type=Path, nargs='+',
    help='provide path to release instruction file',
)
def build_instructions(args):
    """Execute release instruction files and build pods."""

    rules = shipyard.RuleIndex(args)
    builder = shipyard.Builder(args)
    repo = shipyard.release.ReleaseRepo(args.release_root, rules)

    instructions = repo.load_instruction_files(args.instruction)

    with scripts.dry_run(args.dry_run):
        okay = shipyard.release.execute_instructions(
            instructions, repo, builder, args.input_root or ())
    return 0 if okay else 1


@apps.with_help('bind release channel to pod versions')
@apps.with_argument('channel', help='set release channel to bind')
@with_argument_podv_list
def bind(args):
    """Bind release channel to a specific pod versions."""

    channel_root = args.release_root / 'channels' / args.channel
    pods_root = args.release_root / 'pods'

    labels_versions = parse_podv_list(args.podv)

    pod_paths = []
    okay = True
    for label, version in labels_versions:
        pod_path = pods_root / label.path / label.name / version
        pod_paths.append(pod_path)
        if not pod_path.exists():
            LOG.error('pod does not exist: %s@%s', label, version)
            okay = False
    if not okay:
        return 1

    with scripts.dry_run(args.dry_run):
        for (label, next_version), pod_path in zip(labels_versions, pod_paths):
            channel_pod_path = channel_root / label.path / label.name
            if channel_pod_path.exists():
                this_version = channel_pod_path.resolve().name
                if this_version == next_version:
                    LOG.info(
                        'skip binding %s@%s again to channel %s',
                        label, next_version, args.channel)
                    continue
                LOG.info(
                    'rebind %s@%s to channel %s from version %s',
                    label, next_version, args.channel, this_version)
                scripts.rm(channel_pod_path)
            else:
                LOG.info(
                    'bind %s@%s to channel %s',
                    label, next_version, args.channel)
            scripts.mkdir(channel_pod_path.parent)
            scripts.symlink_relative(pod_path, channel_pod_path)

    return 0


@apps.with_argument(
    '--dry-run', action='store_true',
    help='do not execute build',
)
@apps.with_argument(
    '--release-root', type=Path,
    required=not OPS_ROOT,
    default=OPS_ROOT / 'releases' if OPS_ROOT else None,
    help='''provide path to the release directory (default derived from
            OPS_ROOT environment variable, which is %(default)s)
         ''',
)
@apps.with_apps(
    'action', 'release management action',
    read_property,
    generate_instruction,
    cat_instruction,
    build,
    build_instructions,
    bind,
)
def main(args):
    """Release management tool."""
    return args.action(args)


if __name__ == '__main__':
    apps.run(main)
