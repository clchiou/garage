#!/usr/bin/env python3
"""Build application image."""

import contextlib
import json
import logging
import subprocess
import tempfile
from pathlib import Path

import foreman

from startup import startup

import g1.containers.bases
import g1.containers.images
import g1.containers.pods
from g1.apps import bases
from g1.apps import parameters
from g1.bases import argparses
from g1.bases.assertions import ASSERT

LOG = logging.getLogger('build')

PARAMS = parameters.define(
    'shipyard2.build',
    parameters.Namespace(
        base_extra_image_name=parameters.Parameter(
            # Keep this name in sync with bootstrap.sh.
            'base-extra',
            doc='set base-extra image name',
            type=str,
        ),
        ctr_exec=parameters.Parameter(
            'ctr',
            doc='set ctr executable (default to look up from PATH)',
            type=str,
        ),
        foreman_path=parameters.Parameter(
            '/usr/src/garage/shipyard2/scripts/foreman.sh',
            doc='set foreman path inside builder pod',
            type=str,
        ),
        dry_run=parameters.Parameter(
            False,
            doc='whether to dry-run ctr commands',
            type=bool,
        ),
    ),
)

_DEFAULT_FILTERS = (
    # Do not leak any source codes to the application image.
    # Keep this in sync with //apps:build.
    ('exclude', '/home/plumber/drydock'),
    ('exclude', '/usr/src'),
    # Include only relevant files under /etc.
    ('include', '/etc/'),
    ('include', '/etc/group'),
    ('include', '/etc/group-'),
    ('include', '/etc/gshadow'),
    ('include', '/etc/gshadow-'),
    ('include', '/etc/inputrc'),
    ('include', '/etc/ld.so.cache'),
    ('include', '/etc/passwd'),
    ('include', '/etc/passwd-'),
    ('include', '/etc/shadow'),
    ('include', '/etc/shadow-'),
    ('include', '/etc/ssl'),
    ('include', '/etc/subgid'),
    ('include', '/etc/subgid-'),
    ('include', '/etc/subuid'),
    ('include', '/etc/subuid-'),
    ('include', '/etc/sudoers.d'),
    ('exclude', '/etc/**'),
    # Exclude distro binaries from application image (note that base
    # image includes a base set of distro binaries).
    ('exclude', '/bin'),
    ('exclude', '/sbin'),
    ('exclude', '/usr/bin'),
    ('exclude', '/usr/sbin'),
    # Exclude distro systemd files.
    ('exclude', '/lib/systemd'),
    ('exclude', '/usr/lib/systemd'),
    # In general, don't exclude distro libraries since we might depend
    # on them, except distro python libraries.
    ('exclude', '/usr/lib/python*'),
    # Exclude these to save more space.
    ('exclude', '/usr/share'),  # Do we need (portion of) this?
    ('exclude', '/var'),
)


def add_arguments(parser: bases.LABELS.parser) -> bases.LABELS.parse:
    parser.add_argument(
        '--builder-id',
        type=g1.containers.pods.validate_id,
        help='set builder pod id (default to a random one)',
    )
    parser.add_argument(
        '--rule',
        required=True,
        type=foreman.Label.parse,
        help='provide build rule',
    )
    parser.add_argument(
        '--volume',
        action='append',
        help='add volume of the form "source:target[:ro]"',
    )
    parser.add_argument(
        '--image-nv',
        required=True,
        metavar=('NAME', 'VERSION'),
        # Sadly it looks like you can't use ``type`` with ``nargs``.
        nargs=2,
        help='provide application image name and version',
    )
    parser.add_argument(
        '--output',
        required=True,
        type=Path,
        help='provide image output path',
    )
    parser.add_argument(
        '--include-path',
        action=argparses.AppendConstAndValueAction,
        dest='filter',
        const='include',
        help='add output path filter for inclusion'
    )
    parser.add_argument(
        '--exclude-path',
        action=argparses.AppendConstAndValueAction,
        dest='filter',
        const='exclude',
        help='add output path filter for exclusion'
    )


def main(args: bases.LABELS.args):
    g1.containers.bases.assert_root_privilege()
    ctr_exec = PARAMS.ctr_exec.get()
    image_name = g1.containers.images.validate_name(args.image_nv[0])
    image_version = g1.containers.images.validate_version(args.image_nv[1])
    ASSERT.not_predicate(args.output, g1.containers.bases.lexists)
    if args.builder_id is None:
        builder_id = g1.containers.pods.generate_id()
        LOG.info('use builder pod id: %s', builder_id)
    else:
        builder_id = g1.containers.pods.validate_id(args.builder_id)
    with contextlib.ExitStack() as stack:
        config_tempfile = stack.enter_context(
            tempfile.NamedTemporaryFile(mode='w', suffix='.json')
        )
        LOG.info('write builder pod config to: %s', config_tempfile.name)
        json.dump(
            generate_builder_config(
                args.rule,
                list(map(_parse_volume_arg, args.volume or ())),
            ),
            config_tempfile,
        )
        config_tempfile.flush()
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            LOG.debug(
                'pod config contents: %s',
                Path(config_tempfile.name).read_text(),
            )
        # The builder pod might not be cleaned up when `ctr pods run`
        # fails; so let's always do `ctr pods remove` on our way out.
        stack.callback(_run, [ctr_exec, 'pods', 'remove', builder_id])
        LOG.info('start builder pod')
        _run([
            ctr_exec,
            'pods',
            'run',
            *('--id', builder_id),
            config_tempfile.name,
        ])
        LOG.info('export application image to: %s', args.output)
        rootfs_tempdir = stack.enter_context(
            tempfile.TemporaryDirectory(dir=args.output.parent)
        )
        rootfs_tempdir = Path(rootfs_tempdir).absolute() / 'rootfs'
        _run([
            ctr_exec,
            *(('--verbose', )
              if logging.getLogger().isEnabledFor(logging.DEBUG) else ()),
            'pods',
            'export-overlay',
            *('--%s=%s' % pair for pair in _DEFAULT_FILTERS),
            *('--%s=%s' % pair for pair in args.filter or ()),
            builder_id,
            rootfs_tempdir,
        ])
        _run([
            ctr_exec,
            'images',
            'build',
            *('--nv', image_name, image_version),
            *('--rootfs', rootfs_tempdir),
            args.output,
        ])
    return 0


def generate_builder_config(rule, volumes):
    base_image_version = g1.containers.bases.PARAMS.base_image_version.get()
    builder_script = '; '.join((
        'adduser --disabled-password --gecos "" plumber',
        'echo "plumber ALL=(ALL:ALL) NOPASSWD: ALL" > /etc/sudoers.d/99-plumber',
        'chmod 440 /etc/sudoers.d/99-plumber',
        # foreman needs at least python3; let's use 3.8 to be safe.
        # TODO: Get distro (bionic) from `ctr images build-base`.
        'apt-get install --yes software-properties-common',
        'add-apt-repository --yes "deb http://us.archive.ubuntu.com/ubuntu/ bionic main restricted universe"',
        'add-apt-repository --yes "deb http://us.archive.ubuntu.com/ubuntu/ bionic-updates main restricted universe"',
        'add-apt-repository --yes "deb http://security.ubuntu.com/ubuntu bionic-security main restricted universe"',
        'apt-get update',
        'apt-get install --yes python3.8',
        'update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.8 1',
        'update-alternatives --set python3 /usr/bin/python3.8',
        'sudo -u plumber -g plumber "%s" build %s' %
        (PARAMS.foreman_path.get(), str(rule)),
    ))
    return {
        'name':
        'builder',
        'version':
        '0.0.1',
        'apps': [
            {
                'name': 'builder',
                'type': 'oneshot',
                'exec': ['/bin/bash', '-c', builder_script],
                'user': 'root',
                'group': 'root',
            },
        ],
        'images': [
            {
                'name': g1.containers.bases.PARAMS.base_image_name.get(),
                'version': base_image_version,
            },
            {
                'name': PARAMS.base_extra_image_name.get(),
                'version': base_image_version,
            },
        ],
        'volumes': [
            {
                'source': str(_get_repo_root_path()),
                # Target to /usr/src rather than /home/plumber so that
                # /home/plumber is not created and owned by root (which
                # causes adduser to skip copying from /etc/skel).  Also,
                # /usr/src seems to be a nice place for read-only source
                # repositories.
                'target': '/usr/src/garage',
                'read_only': True
            },
            *volumes,
        ],
    }


def _get_repo_root_path():
    repo_root_path = Path(__file__).parent.parent.parent
    ASSERT.predicate(repo_root_path / '.git', g1.containers.bases.lexists)
    return repo_root_path


def _parse_volume_arg(arg):
    parts = arg.split(':')
    if ASSERT.in_(len(parts), (2, 3)) == 3:
        source, target, read_only = parts
        read_only = read_only == 'ro'
    else:
        source, target = parts
        read_only = False
    return {'source': source, 'target': target, 'read_only': read_only}


def _run(args):
    args = list(map(str, args))
    LOG.debug('run: %s', args)
    if not PARAMS.dry_run.get():
        subprocess.run(args, check=True)


if __name__ == '__main__':
    startup(add_arguments)
    bases.run(main, prog='build')
